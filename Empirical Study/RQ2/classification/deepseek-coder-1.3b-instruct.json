{
     "datas": [
          {
               "id": "6367670b1a6d9265ec017a00",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n    if(array1 == null || array2 == null){\n        return false;\n    }\n    return array1.length == array2.length;\n}",
               "ground_true": "public static boolean isSameLength(final byte[] array1,final byte[] array2){\n  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n    return false;\n  }\n  return true;\n}\n"
          },
          {
               "id": "636767081a6d9265ec017989",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public static boolean[] toPrimitive(final Boolean[] array){\n    return (array == null || array.length == 0) ? EMPTY_BOOLEAN_ARRAY : Arrays.stream(array).map(Boolean::booleanValue).collect(Collectors.toList()).toArray(EMPTY_BOOLEAN_ARRAY);\n}",
               "ground_true": "public static boolean[] toPrimitive(final Boolean[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_ARRAY;\n  }\n  final boolean[] result=new boolean[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].booleanValue();\n  }\n  return result;\n}\n"
          },
          {
               "id": "636767031a6d9265ec0178e6",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public static byte[] toPrimitive(final Byte[] array){\n    if(array == null){\n        return null;\n    }\n    byte[] primitives = new byte[array.length];\n    for(int i = 0; i < array.length; i++){\n        primitives[i] = (byte) array[i];\n    }\n    return primitives;\n}",
               "ground_true": "public static byte[] toPrimitive(final Byte[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_BYTE_ARRAY;\n  }\n  final byte[] result=new byte[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].byteValue();\n  }\n  return result;\n}\n"
          },
          {
               "id": "636767001a6d9265ec017873",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public static String reverse(final String str){\n    return new StringBuilder(str).reverse().toString();\n}",
               "ground_true": "public static String reverse(final String str){\n  if (str == null) {\n    return null;\n  }\n  return new StringBuilder(str).reverse().toString();\n}\n"
          },
          {
               "id": "636766ff1a6d9265ec01784b",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    1,
                    2
               ],
               "generate_code": "public static boolean isDigits(String str){\n    return str.matches(\"\\\\d+\");\n}",
               "ground_true": "public static boolean isDigits(String str){\n  if ((str == null) || (str.length() == 0)) {\n    return false;\n  }\n  for (int i=0; i < str.length(); i++) {\n    if (!Character.isDigit(str.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}\n"
          },
          {
               "id": "6367670c1a6d9265ec017a35",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n    if(str == null || suffix == null){\n        return str == null && suffix == null;\n    }\n    if(ignoreCase){\n        return str.equalsIgnoreCase(suffix);\n    }else{\n        return str.endsWith(suffix);\n    }\n}",
               "ground_true": "private static boolean endsWith(final String str,final String suffix,final boolean ignoreCase){\n  if (str == null || suffix == null) {\n    return str == null && suffix == null;\n  }\n  if (suffix.length() > str.length()) {\n    return false;\n  }\n  int strOffset=str.length() - suffix.length();\n  return str.regionMatches(ignoreCase,strOffset,suffix,0,suffix.length());\n}\n"
          },
          {
               "id": "636766ff1a6d9265ec017842",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public static double[] toPrimitive(final Double[] array){\n    if(array.length == 0){\n        return EMPTY_DOUBLE_ARRAY;\n    }\n    double[] result = new double[array.length];\n    for(int i = 0; i < array.length; i++){\n        result[i] = array[i].doubleValue();\n    }\n    return result;\n}",
               "ground_true": "public static double[] toPrimitive(final Double[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_DOUBLE_ARRAY;\n  }\n  final double[] result=new double[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].doubleValue();\n  }\n  return result;\n}\n"
          },
          {
               "id": "636767081a6d9265ec0179a2",
               "type": [
                    "Missing Null Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    1,
                    3
               ],
               "generate_code": "private static boolean isAllZeros(String s){\n    return \"0\".equals(s);\n}",
               "ground_true": "private static boolean isAllZeros(String s){\n  if (s == null) {\n    return true;\n  }\n  for (int i=s.length() - 1; i >= 0; i--) {\n    if (s.charAt(i) != '0') {\n      return false;\n    }\n  }\n  return s.length() > 0;\n}\n"
          },
          {
               "id": "6367670c1a6d9265ec017a2a",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public static int[] toPrimitive(final Integer[] array){\n    if(array == null){\n        return EMPTY_INT_ARRAY;\n    }\n    int[] primitiveArray = new int[array.length];\n    for(int i = 0; i < array.length; i++){\n        primitiveArray[i] = array[i].intValue();\n    }\n    return primitiveArray;\n}",
               "ground_true": "public static int[] toPrimitive(final Integer[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_INT_ARRAY;\n  }\n  final int[] result=new int[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i].intValue();\n  }\n  return result;\n}\n"
          },
          {
               "id": "636766fa1a6d9265ec017796",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public static Boolean[] toObject(final boolean[] array){\n    if(array == null){\n        return null;\n    }\n    final Boolean[] result = new Boolean[array.length];\n    for(int i = 0; i < array.length; i++){\n        result[i] = array[i];\n    }\n    return result;\n}",
               "ground_true": "public static Boolean[] toObject(final boolean[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY;\n  }\n  final Boolean[] result=new Boolean[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=array[i] ? Boolean.TRUE : Boolean.FALSE;\n  }\n  return result;\n}\n"
          },
          {
               "id": "6367670a1a6d9265ec0179f1",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public static Short[] toObject(final short[] array){\n    if(array == null){\n        return null;\n    }\n    Short[] result = new Short[array.length];\n    for(int i = 0; i < array.length; i++){\n        result[i] = Short.valueOf(array[i]);\n    }\n    return result;\n}",
               "ground_true": "public static Short[] toObject(final short[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY;\n  }\n  final Short[] result=new Short[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=new Short(array[i]);\n  }\n  return result;\n}\n"
          },
          {
               "id": "636767041a6d9265ec01790f",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public static Integer[] toObject(final int[] array){\n    if(array == null){\n        return null;\n    }\n    Integer[] result = new Integer[array.length];\n    for(int i = 0; i < array.length; i++){\n        result[i] = Integer.valueOf(array[i]);\n    }\n    return result;\n}",
               "ground_true": "public static Integer[] toObject(final int[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY;\n  }\n  final Integer[] result=new Integer[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=new Integer(array[i]);\n  }\n  return result;\n}\n"
          },
          {
               "id": "636766fa1a6d9265ec0177a4",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public static Double[] toObject(final double[] array){\n    if(array == null){\n        return null;\n    }\n    Double[] result = new Double[array.length];\n    for(int i = 0; i < array.length; i++){\n        result[i] = Double.valueOf(array[i]);\n    }\n    return result;\n}",
               "ground_true": "public static Double[] toObject(final double[] array){\n  if (array == null) {\n    return null;\n  }\n else   if (array.length == 0) {\n    return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY;\n  }\n  final Double[] result=new Double[array.length];\n  for (int i=0; i < array.length; i++) {\n    result[i]=new Double(array[i]);\n  }\n  return result;\n}\n"
          },
          {
               "id": "636767151a6d9265ec017b6b",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n    if(str == null || prefix == null){\n        return str == null && prefix == null;\n    }\n    if(ignoreCase){\n        return str.regionMatches(true,0,prefix,0,prefix.length());\n    }\n    return str.startsWith(prefix);\n}",
               "ground_true": "private static boolean startsWith(final String str,final String prefix,final boolean ignoreCase){\n  if (str == null || prefix == null) {\n    return str == null && prefix == null;\n  }\n  if (prefix.length() > str.length()) {\n    return false;\n  }\n  return str.regionMatches(ignoreCase,0,prefix,0,prefix.length());\n}\n"
          },
          {
               "id": "636766fe1a6d9265ec01781c",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public static Character toCharacterObject(final char ch){\n    return Character.valueOf(ch);\n}",
               "ground_true": "public static Character toCharacterObject(final char ch){\n  if (ch < CharUtils.CHAR_ARRAY.length) {\n    return CharUtils.CHAR_ARRAY[ch];\n  }\n  return new Character(ch);\n}\n"
          },
          {
               "id": "636766f81a6d9265ec017748",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    1,
                    2
               ],
               "generate_code": "public static String base64Decode(final String s){\n    return new String(Base64.getDecoder().decode(s), StandardCharsets.UTF_8);\n}",
               "ground_true": "public static String base64Decode(final String s){\n  byte[] b=Base64.base64DecodeToArray(s);\n  if (b == null) {\n    return null;\n  }\n  if (b.length == 0) {\n    return \"\";\n  }\n  return new String(b,StandardCharsets.UTF_8);\n}\n"
          },
          {
               "id": "636766f11a6d9265ec017663",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public static boolean isSameLength(final double[] array1,final double[] array2){\n    if(array1 == null && array2 == null) return true;\n    if(array1 == null || array2 == null) return false;\n    return array1.length == array2.length;\n}",
               "ground_true": "public static boolean isSameLength(final double[] array1,final double[] array2){\n  if (array1 == null && array2 != null && array2.length > 0 || array2 == null && array1 != null && array1.length > 0 || array1 != null && array2 != null && array1.length != array2.length) {\n    return false;\n  }\n  return true;\n}\n"
          },
          {
               "id": "636766f31a6d9265ec01768f",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public static char[] clone(final char[] array){\n    return Arrays.copyOf(array, array.length);\n}",
               "ground_true": "public static char[] clone(final char[] array){\n  if (array == null) {\n    return null;\n  }\n  return array.clone();\n}\n"
          },
          {
               "id": "6367670b1a6d9265ec017a05",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public static String toString(final char ch){\n    return String.valueOf(ch);\n}",
               "ground_true": "public static String toString(final char ch){\n  if (ch < 128) {\n    return CharUtils.CHAR_STRING_ARRAY[ch];\n  }\n  return new String(new char[]{ch});\n}\n"
          },
          {
               "id": "636767191a6d9265ec017c0f",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "private void enlarge(final int size){\n    byte[] newData = new byte[data.length + size];\n    System.arraycopy(data, 0, newData, 0, data.length);\n    data = newData;\n}",
               "ground_true": "private void enlarge(final int size){\n  int doubleCapacity=2 * data.length;\n  int minimalCapacity=length + size;\n  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n  System.arraycopy(data,0,newData,0,length);\n  data=newData;\n}\n"
          },
          {
               "id": "636766fa1a6d9265ec0177a9",
               "type": [
                    "Missing Null Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    1,
                    3
               ],
               "generate_code": "private void addInitializedType(final int abstractType){\n    this.initializations[initializationCount++] = abstractType;\n}",
               "ground_true": "private void addInitializedType(final int abstractType){\n  if (initializations == null) {\n    initializations=new int[2];\n  }\n  int initializationsLength=initializations.length;\n  if (initializationCount >= initializationsLength) {\n    int[] newInitializations=new int[Math.max(initializationCount + 1,2 * initializationsLength)];\n    System.arraycopy(initializations,0,newInitializations,0,initializationsLength);\n    initializations=newInitializations;\n  }\n  initializations[initializationCount++]=abstractType;\n}\n"
          },
          {
               "id": "636766f81a6d9265ec017758",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "@Override public int hashCode(){\n    int result = 17;\n    result = 31 * result + sort;\n    result = 31 * result + ((valueBuffer == null) ? 0 : valueBuffer.hashCode());\n    result = 31 * result + valueBegin;\n    result = 31 * result + valueEnd;\n    return result;\n}",
               "ground_true": "@Override public int hashCode(){\n  int hashCode=13 * (sort == INTERNAL ? OBJECT : sort);\n  if (sort >= ARRAY) {\n    for (int i=valueBegin, end=valueEnd; i < end; i++) {\n      hashCode=17 * (hashCode + valueBuffer.charAt(i));\n    }\n  }\n  return hashCode;\n}\n"
          },
          {
               "id": "636766fe1a6d9265ec017823",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks",
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    1,
                    2,
                    4
               ],
               "generate_code": "int addConstantNameAndType(final String name,final String descriptor){\n    int index = constantPool.add(new ConstantUtf8(name));\n    constantPool.add(new ConstantUtf8(descriptor));\n    return index;\n}",
               "ground_true": "int addConstantNameAndType(final String name,final String descriptor){\n  final int tag=Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n  int hashCode=hash(tag,name,descriptor);\n  Entry entry=get(hashCode);\n  while (entry != null) {\n    if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) {\n      return entry.index;\n    }\n    entry=entry.next;\n  }\n  constantPool.put122(tag,addConstantUtf8(name),addConstantUtf8(descriptor));\n  return put(new Entry(constantPoolCount++,tag,name,descriptor,hashCode)).index;\n}\n"
          },
          {
               "id": "636767131a6d9265ec017b23",
               "type": [
                    "Missing Specific Value Checks",
                    "Missing Range Checks",
                    "Missing Null Checks"
               ],
               "type_id": [
                    2,
                    3,
                    1
               ],
               "generate_code": "final void addLineNumber(final int lineNumber){\n    this.lineNumber = lineNumber;\n}",
               "ground_true": "final void addLineNumber(final int lineNumber){\n  if (this.lineNumber == 0) {\n    this.lineNumber=(short)lineNumber;\n  }\n else {\n    if (otherLineNumbers == null) {\n      otherLineNumbers=new int[LINE_NUMBERS_CAPACITY_INCREMENT];\n    }\n    int otherLineNumberIndex=++otherLineNumbers[0];\n    if (otherLineNumberIndex >= otherLineNumbers.length) {\n      int[] newLineNumbers=new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];\n      System.arraycopy(otherLineNumbers,0,newLineNumbers,0,otherLineNumbers.length);\n      otherLineNumbers=newLineNumbers;\n    }\n    otherLineNumbers[otherLineNumberIndex]=lineNumber;\n  }\n}\n"
          },
          {
               "id": "636767061a6d9265ec01794a",
               "type": [
                    "Missing Null Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    1,
                    3
               ],
               "generate_code": "public static int indexOfExtension(String filename){\n    int lastSeparatorIndex = indexOfLastSeparator(filename);\n    if(lastSeparatorIndex == -1){\n        return -1;\n    }\n    return lastSeparatorIndex + getExtension(filename).length();\n}",
               "ground_true": "public static int indexOfExtension(String filename){\n  if (filename == null) {\n    return -1;\n  }\n  int extensionPos=filename.lastIndexOf(EXTENSION_SEPARATOR);\n  int lastSeparator=indexOfLastSeparator(filename);\n  return lastSeparator > extensionPos ? -1 : extensionPos;\n}\n"
          },
          {
               "id": "6367670a1a6d9265ec0179d8",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "@Override public void write(final byte[] b) throws IOException {\n    write(b, 0, b.length);\n}",
               "ground_true": "@Override public void write(final byte[] b) throws IOException {\n  if (this.encoding == null) {\n    this.writer.write(new String(b));\n  }\n else {\n    this.writer.write(new String(b,this.encoding));\n  }\n}\n"
          },
          {
               "id": "636767001a6d9265ec01787e",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    1,
                    2
               ],
               "generate_code": "public String toString(){\n    return toString(null);\n}",
               "ground_true": "public String toString(){\n  if (this.getObject() == null) {\n    return this.getStyle().getNullText();\n  }\n  Class<?> clazz=this.getObject().getClass();\n  this.appendFieldsIn(clazz);\n  while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n    clazz=clazz.getSuperclass();\n    this.appendFieldsIn(clazz);\n  }\n  return super.toString();\n}\n"
          },
          {
               "id": "636767041a6d9265ec017911",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "static void register(Object value){\n    if(value != null){\n        getRegistry().put(value, Boolean.TRUE);\n    }\n}",
               "ground_true": "static void register(Object value){\n  if (value != null) {\n    Map m=getRegistry();\n    if (m == null) {\n      m=new WeakHashMap();\n      REGISTRY.set(m);\n    }\n    m.put(value,null);\n  }\n}\n"
          },
          {
               "id": "636766f11a6d9265ec017641",
               "type": [
                    "Errorous Expression",
                    "Missing Range Checks",
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    8,
                    3,
                    4
               ],
               "generate_code": "@Override public int available() throws IOException {\n    if (byteArrayOut != null) {\n        return byteArrayOut.available();\n    } else if (reader != null) {\n        return reader.available();\n    } else {\n        return 0;\n    }\n}",
               "ground_true": "@Override public int available() throws IOException {\n  return this.index < this.length ? this.length - this.index : this.length >= 0 && this.reader.ready() ? 1 : 0;\n}\n"
          },
          {
               "id": "636766f91a6d9265ec01777d",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public static byte convertHexDigit(byte b){\n    int i = b & 0xff;\n    if(i<10) return (byte)(i + '0');\n    else return (byte)(i - 10 + 'A');\n}",
               "ground_true": "public static byte convertHexDigit(byte b){\n  if ((b >= '0') && (b <= '9'))   return (byte)(b - '0');\n  if ((b >= 'a') && (b <= 'f'))   return (byte)(b - 'a' + 10);\n  if ((b >= 'A') && (b <= 'F'))   return (byte)(b - 'A' + 10);\n  throw new IllegalArgumentException(\"!hex:\" + Integer.toHexString(0xff & b));\n}\n"
          },
          {
               "id": "6367670a1a6d9265ec0179e7",
               "type": [
                    "Missing Null Checks",
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    1,
                    4
               ],
               "generate_code": "public Converter lookup(final Class<?> clazz){\n    return converters.get(clazz);\n}",
               "ground_true": "public Converter lookup(final Class<?> clazz){\n  Converter conv=(Converter)this.converters.get(clazz);\n  if (conv != null) {\n    return conv;\n  }\n  for (  Object regType : this.converters.keySet()) {\n    if (((Class<?>)regType).isAssignableFrom(clazz)) {\n      return (Converter)this.converters.get(regType);\n    }\n  }\n  return null;\n}\n"
          },
          {
               "id": "6367670b1a6d9265ec0179f2",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "@Override public boolean containsKey(final Object key){\n  return map.containsKey(key);\n}",
               "ground_true": "@Override public boolean containsKey(final Object key){\n  if (this.fast) {\n    return this.map.containsKey(key);\n  }\n else {\nsynchronized (this.map) {\n      return this.map.containsKey(key);\n    }\n  }\n}\n"
          },
          {
               "id": "636766f11a6d9265ec01764f",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "public Collection<Object> values(){\n    return Collections.unmodifiableList(new ArrayList<>(map.values()));\n}",
               "ground_true": "public Collection<Object> values(){\n  ArrayList<Object> answer=new ArrayList<>(readMethods.size());\n  for (Iterator<Object> iter=valueIterator(); iter.hasNext(); ) {\n    answer.add(iter.next());\n  }\n  return Collections.unmodifiableList(answer);\n}\n"
          },
          {
               "id": "636767071a6d9265ec017962",
               "type": [
                    "Missing Null Checks",
                    "Errorous Expression"
               ],
               "type_id": [
                    1,
                    8
               ],
               "generate_code": "public void putAllWriteable(BeanMap map){\n  for (Map.Entry<String,Method> entry : map.entrySet()) {\n    if (entry.getValue().getDeclaringClass().equals(this.getClass())) {\n      this.put(entry.getKey(),entry.getValue());\n    }\n  }\n}",
               "ground_true": "public void putAllWriteable(BeanMap map){\n  Iterator<String> readableKeys=map.readMethods.keySet().iterator();\n  while (readableKeys.hasNext()) {\n    String key=readableKeys.next();\n    if (getWriteMethod(key) != null) {\n      this.put(key,map.get(key));\n    }\n  }\n}\n"
          },
          {
               "id": "636766f81a6d9265ec01774b",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public byte readByte() throws IOException {\n    if (closed) {\n        throw new IOException(\"Stream closed\");\n    }\n    int r = input.read();\n    if (r == -1) {\n        closed = true;\n        return -1;\n    }\n    total++;\n    return (byte) r;\n}",
               "ground_true": "public byte readByte() throws IOException {\n  if (head == tail) {\n    head=0;\n    tail=input.read(buffer,head,bufSize);\n    if (tail == -1) {\n      throw new IOException(\"No more data is available\");\n    }\n  }\n  return buffer[head++];\n}\n"
          },
          {
               "id": "6367670b1a6d9265ec017a0f",
               "type": [
                    "Missing Null Checks",
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    1,
                    4
               ],
               "generate_code": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n    for(String searchStr : searchStrArray){\n        if(containsIgnoreCase(str,searchStr)){\n            return true;\n        }\n    }\n    return false;\n}",
               "ground_true": "public static boolean containsAnyIgnoreCase(String str,List<String> searchStrArray){\n  if (StringUtils.isEmpty(str) || searchStrArray == null || searchStrArray.isEmpty()) {\n    return false;\n  }\n  for (  String item : searchStrArray) {\n    if (containsIgnoreCase(str,item)) {\n      return true;\n    }\n  }\n  return false;\n}\n"
          },
          {
               "id": "636767021a6d9265ec0178bc",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public static int indexOf(String str,String searchStr){\n    return str.indexOf(searchStr);\n}",
               "ground_true": "public static int indexOf(String str,String searchStr){\n  if (str == null || searchStr == null) {\n    return StringUtils.INDEX_NOT_FOUND;\n  }\n  return str.indexOf(searchStr);\n}\n"
          },
          {
               "id": "636767031a6d9265ec0178ef",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n    int oldCapacity = getArrayLength(array);\n    int newCapacity = oldCapacity + 1;\n    @SuppressWarnings(\"unchecked\")\n    Object newArray = Array.newInstance(newArrayComponentType, newCapacity);\n    System.arraycopy(array, 0, newArray, 0, oldCapacity);\n    return newArray;\n}",
               "ground_true": "private static Object copyArrayGrow1(final Object array,final Class<?> newArrayComponentType){\n  if (array != null) {\n    int arrayLength=Array.getLength(array);\n    Object newArray=Array.newInstance(array.getClass().getComponentType(),arrayLength + 1);\n    System.arraycopy(array,0,newArray,0,arrayLength);\n    return newArray;\n  }\n  return Array.newInstance(newArrayComponentType,1);\n}\n"
          },
          {
               "id": "636766fe1a6d9265ec017834",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public static String sessionId(){\n    HttpSession session = Invoker.getCurrentRequest().getSession();\n    return session.getId();\n}",
               "ground_true": "public static String sessionId(){\n  HttpSession httpSession=servletSession();\n  if (httpSession == null) {\n    return null;\n  }\n  return httpSession.getId();\n}\n"
          },
          {
               "id": "636766ae1a6d9265ec0175dc",
               "type": [
                    "Missing Range Checks",
                    "Missing Null Checks"
               ],
               "type_id": [
                    3,
                    1
               ],
               "generate_code": "public Boolean isPartialContentResponse(){\n    return response.getStatus() == HttpStatus.PARTIAL_CONTENT_STATUS;\n}",
               "ground_true": "public Boolean isPartialContentResponse(){\n  Integer limit=drc.getLimit() == null ? 0 : drc.getLimit();\n  Long count=drc.getCount() == null ? 0 : drc.getCount();\n  return !((limit + 1) >= count);\n}\n"
          },
          {
               "id": "636766ae1a6d9265ec0175d8",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "private String buildContentRange(){\n    int offset = this.offset;\n    int limit = this.limit;\n    int count = this.count;\n    String contentRange = offset + \"-\" + ((limit == 0) ? (count - 1) : limit) + \"/\" + count;\n    return contentRange;\n}",
               "ground_true": "private String buildContentRange(){\n  Integer limit=drc.getLimit() == null ? getDefaultNumberPagination() - 1 : drc.getLimit();\n  Integer offset=drc.getOffset() == null ? 0 : drc.getOffset();\n  Long count=drc.getCount() == null ? 0 : drc.getCount();\n  return offset + \"-\" + (limit.equals(0) ? count - 1 : limit)+ \"/\"+ count;\n}\n"
          },
          {
               "id": "636766f01a6d9265ec01763e",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "private static String javaCharset(String charset){\n    return MIME2JAVA.get(charset);\n}",
               "ground_true": "private static String javaCharset(String charset){\n  if (charset == null) {\n    return null;\n  }\n  String mappedCharset=MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));\n  if (mappedCharset == null) {\n    return charset;\n  }\n  return mappedCharset;\n}\n"
          },
          {
               "id": "636767631a6d9265ec018171",
               "type": [
                    "Missing Boolean Value Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    4,
                    2
               ],
               "generate_code": "private boolean unlink(ListNodeImpl<E> node){\n    if(node == null)\n        return false;\n    if(node.getPrev() == node){\n        node.getNext().setPrev(null);\n    }else{\n        node.getPrev().setNext(node.getNext());\n        node.getNext().setPrev(node.getPrev());\n    }\n    node.setNext(null);\n    node.setPrev(null);\n    size--;\n    return true;\n}",
               "ground_true": "private boolean unlink(ListNodeImpl<E> node){\n  ListNodeImpl<E> prev=node.prev;\n  ListNodeImpl<E> next=node.next;\n  if (removeListNode(node)) {\n    if (size == 0) {\n      head=null;\n    }\n else {\n      link(prev,next);\n      if (head == node) {\n        head=next;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n"
          },
          {
               "id": "6367674a1a6d9265ec017da9",
               "type": [
                    "Missing Assertions",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    6,
                    2
               ],
               "generate_code": "private void moveAllListNodes(DoublyLinkedList<E> list){\n    DoublyLinkedList<E> newList = new DoublyLinkedList<>();\n    ListNodeImpl<E> currentNode = list.head;\n    while(currentNode != null){\n        newList.addLast(currentNode.getValue());\n        currentNode = currentNode.getNext();\n    }\n    this.list = newList;\n}",
               "ground_true": "private void moveAllListNodes(DoublyLinkedList<E> list){\n  for (ListNodeIteratorImpl it=list.new ListNodeIteratorImpl(0); it.hasNext(); ) {\n    ListNodeImpl<E> node=it.nextNode();\n    assert node.list == list;\n    node.list=this;\n  }\n  size+=list.size;\n  list.size=0;\n  modCount++;\n  list.modCount++;\n}\n"
          },
          {
               "id": "636767531a6d9265ec017efb",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "void insertBefore(Bucket bucket){\n    if(bucketMap.containsKey(bucket.getVertex())){\n        Bucket prevBucket = bucketMap.get(bucket.getVertex());\n        bucket.setNext(prevBucket);\n        prevBucket.setPrev(bucket);\n        bucketMap.put(bucket.getVertex(), bucket);\n    }\n    else{\n        throw new NoSuchElementException(\"Bucket does not exist\");\n    }\n}",
               "ground_true": "void insertBefore(Bucket bucket){\n  this.next=bucket;\n  if (bucket != null) {\n    this.prev=bucket.prev;\n    if (bucket.prev != null) {\n      bucket.prev.next=this;\n    }\n    bucket.prev=this;\n  }\n else {\n    this.prev=null;\n  }\n}\n"
          },
          {
               "id": "636767561a6d9265ec017f63",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    1,
                    2
               ],
               "generate_code": "@Override public boolean hasNext(){\n    return !vertices.isEmpty();\n}",
               "ground_true": "@Override public boolean hasNext(){\n  if (current != null) {\n    return true;\n  }\n  current=advance();\n  if (current != null && nListeners != 0) {\n    fireVertexTraversed(createVertexTraversalEvent(current));\n  }\n  return current != null;\n}\n"
          },
          {
               "id": "6367674b1a6d9265ec017dc0",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "private Set<V> initVisibleVertices(){\n    Set<V> visibleVertices = new HashSet<V>();\n    for(E e : graph.edgeSet()){\n        V v1 = graph.getEdgeSource(e);\n        V v2 = graph.getEdgeTarget(e);\n        visibleVertices.add(v1);\n        visibleVertices.add(v2);\n    }\n    return visibleVertices;\n}",
               "ground_true": "private Set<V> initVisibleVertices(){\n  Set<V> visibleVertex=new HashSet<>();\n  for (  E e : graph.edgeSet()) {\n    V s=graph.getEdgeSource(e);\n    V t=graph.getEdgeTarget(e);\n    if (!s.equals(t)) {\n      visibleVertex.add(s);\n      visibleVertex.add(t);\n    }\n  }\n  return visibleVertex;\n}\n"
          },
          {
               "id": "6367675c1a6d9265ec01805b",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public void removeFromTreeEdgeList(){\n    if(prev != null){\n        prev[0].remove(this);\n    }\n    if(next != null){\n        next[0].remove(this);\n    }\n}",
               "ground_true": "public void removeFromTreeEdgeList(){\n  for (int dir=0; dir < 2; dir++) {\n    if (prev[dir] != null) {\n      prev[dir].next[dir]=next[dir];\n    }\n else {\n      head[1 - dir].first[dir]=next[dir];\n    }\n    if (next[dir] != null) {\n      next[dir].prev[dir]=prev[dir];\n    }\n  }\n  head[0]=head[1]=null;\n}\n"
          },
          {
               "id": "636767531a6d9265ec017ef1",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public static boolean equals(Point2D p1,Point2D p2){\n    return TOLERANCE_DOUBLE_COMPARATOR.equals(p1, p2);\n}",
               "ground_true": "public static boolean equals(Point2D p1,Point2D p2){\n  int xEquals=TOLERANCE_DOUBLE_COMPARATOR.compare(p1.getX(),p2.getX());\n  if (xEquals != 0) {\n    return false;\n  }\n  return TOLERANCE_DOUBLE_COMPARATOR.compare(p1.getY(),p2.getY()) == 0;\n}\n"
          },
          {
               "id": "636767431a6d9265ec017c8d",
               "type": [
                    "Missing Assertions",
                    "Missing Range Checks"
               ],
               "type_id": [
                    6,
                    3
               ],
               "generate_code": "private int computeBinaryLog(int n){\n    return (int) Math.floor(Math.log(n) / Math.log(2));\n}",
               "ground_true": "private int computeBinaryLog(int n){\n  assert n >= 0;\n  int result=0;\n  while (n > 0) {\n    n>>=1;\n    ++result;\n  }\n  return result;\n}\n"
          },
          {
               "id": "636767611a6d9265ec018116",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n    return set1.stream().filter(set2::contains).collect(Collectors.toSet());\n}",
               "ground_true": "private Set<V> intersection(Set<V> set1,Set<V> set2){\n  Set<V> a;\n  Set<V> b;\n  if (set1.size() <= set2.size()) {\n    a=set1;\n    b=set2;\n  }\n else {\n    a=set2;\n    b=set1;\n  }\n  return a.stream().filter(b::contains).collect(Collectors.toSet());\n}\n"
          },
          {
               "id": "636767511a6d9265ec017eb6",
               "type": [
                    "Missing Specific Value Checks",
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    2,
                    4
               ],
               "generate_code": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n    return new OuterFaceCirculator(start,dir);\n}",
               "ground_true": "private OuterFaceCirculator selectOnOuterFace(Predicate<Node> predicate,Node start,Node stop,int dir){\n  OuterFaceCirculator circulator=start.iterator(dir);\n  Node current=circulator.next();\n  while (current != stop && !predicate.test(current)) {\n    current=circulator.next();\n  }\n  return circulator;\n}\n"
          },
          {
               "id": "6367675d1a6d9265ec018082",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "Edge edgeToNext(){\n    return new Edge(graphEdge,source,target);\n}",
               "ground_true": "Edge edgeToNext(){\n  Edge edge=prev.embedded.getFirst();\n  Node target=toExistingNode(current);\n  Node source=toExistingNode(prev);\n  if (edge.getOpposite(source) == target) {\n    return edge;\n  }\n else {\n    return prev.embedded.getLast();\n  }\n}\n"
          },
          {
               "id": "636767611a6d9265ec018112",
               "type": [
                    "Missing Range Checks",
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    3,
                    4
               ],
               "generate_code": "@Override protected V provideNextVertex(){\n    if(path.isEmpty()){\n        return null;\n    }\n    V currentVertex = path.get(0);\n    path.remove(0);\n    return currentVertex;\n}",
               "ground_true": "@Override protected V provideNextVertex(){\n  V v=super.provideNextVertex();\n  for (int i=path.size() - 1; i >= 0; --i) {\n    if (graph.containsEdge(path.get(i),v)) {\n      break;\n    }\n    path.remove(i);\n  }\n  path.add(v);\n  return v;\n}\n"
          },
          {
               "id": "636767601a6d9265ec0180e2",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n    List<Pair<List<Pair<Integer,Integer>>,E>> result = new ArrayList<>();\n    for(E edge : graph.edgeSet()){\n        List<Pair<Integer,Integer>> separators = new ArrayList<>();\n        for(V vertex : graph.neighborVertexList(edge)){\n            List<V> separator = getSeparator(graph,vertex,new HashMap<>());\n            separators.add(new Pair<>(separator.size(),separator.indexOf(vertex)));\n        }\n        result.add(new Pair<>(separators,edge));\n    }\n    return result;\n}",
               "ground_true": "private List<Pair<List<Pair<Integer,Integer>>,E>> computeGlobalSeparatorList(){\n  List<Pair<List<Pair<Integer,Integer>>,E>> globalSeparatorList=new ArrayList<>();\n  for (  E edge : graph.edgeSet()) {\n    V source=graph.getEdgeSource(edge);\n    V target=graph.getEdgeTarget(edge);\n    if (source != target) {\n      List<Set<V>> edgeSeparators=findSeparators(graph,edge);\n      globalSeparatorList.addAll(reformatSeparatorList(edgeSeparators,edge));\n    }\n  }\n  return globalSeparatorList;\n}\n"
          },
          {
               "id": "6367675f1a6d9265ec0180cf",
               "type": [
                    "Missing Boolean Value Checks",
                    "Missing Null Checks"
               ],
               "type_id": [
                    4,
                    1
               ],
               "generate_code": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n    return graph.vertexSet().containsAll(vertices);\n}",
               "ground_true": "private static <V,E>boolean isClique(Graph<V,E> graph,Set<V> vertices){\n  for (  V v1 : vertices) {\n    for (    V v2 : vertices) {\n      if (!v1.equals(v2) && (graph.getEdge(v1,v2) == null)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n"
          },
          {
               "id": "636767511a6d9265ec017eb0",
               "type": [
                    "Missing Assertions",
                    "Missing Range Checks"
               ],
               "type_id": [
                    6,
                    3
               ],
               "generate_code": "public int nonZeros(int row){\n    return rowOffsets[row + 1] - rowOffsets[row];\n}",
               "ground_true": "public int nonZeros(int row){\n  assert row >= 0 && row < rowOffsets.length;\n  return rowOffsets[row + 1] - rowOffsets[row];\n}\n"
          },
          {
               "id": "636767461a6d9265ec017d17",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "private String unescapeId(String input){\n    return unescapeHtmlString(input);\n}",
               "ground_true": "private String unescapeId(String input){\n  final char quote='\"';\n  if (input.charAt(0) != quote || input.charAt(input.length() - 1) != quote) {\n    return input;\n  }\n  String noQuotes=input.subSequence(1,input.length() - 1).toString();\n  String unescaped=unescapeId.translate(noQuotes);\n  return unescaped;\n}\n"
          },
          {
               "id": "6367667f1a6d9265ec01745d",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    1,
                    2,
                    3
               ],
               "generate_code": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n    List<PathSegmentImpl> segments = new ArrayList<>();\n    String path = u.getPath();\n    if(decode){\n        String[] pathSegments = path.split(\"/\");\n        for(String segment : pathSegments){\n            segments.add(new PathSegmentImpl(segment,true));\n        }\n    }else{\n        segments.add(new PathSegmentImpl(path,false));\n    }\n    return segments;\n}",
               "ground_true": "public static List<PathSegmentImpl> decodePath(URI u,boolean decode){\n  String rawPath=u.getRawPath();\n  if (rawPath != null && rawPath.length() > 0 && rawPath.charAt(0) == '/') {\n    rawPath=rawPath.substring(1);\n  }\n  return decodePath(rawPath,decode);\n}\n"
          },
          {
               "id": "636766861a6d9265ec01755a",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    1,
                    2
               ],
               "generate_code": "public final MatchResult match(CharSequence uri){\n    if(uri == null){\n        throw new NullPointerException(\"uri is marked non-null but is null\");\n    }\n    Matcher matcher = regexPattern.matcher(uri);\n    if(matcher.find()){\n        return new GroupIndexMatchResult(matcher);\n    }\n    return null;\n}",
               "ground_true": "public final MatchResult match(CharSequence uri){\n  if (uri == null || uri.length() == 0)   return (regexPattern == null) ? EMPTY_STRING_MATCH_RESULT : null;\n else   if (regexPattern == null)   return null;\n  Matcher m=regexPattern.matcher(uri);\n  if (!m.matches())   return null;\n  return (groupIndexes.length > 0) ? new GroupIndexMatchResult(m) : m;\n}\n"
          },
          {
               "id": "6367667f1a6d9265ec01745c",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n    try{\n        File f = new File(dir);\n        File[] files = f.listFiles(new FilenameFilter(){\n            public boolean accept(File dir,String name){\n                return name.toLowerCase().matches(\".*\\\\.(jar)$\");\n            }\n        });\n        if(files != null){\n            for(int i = 0; i < files.length; i++){\n                cpV.add(files[i].toURI().toURL());\n            }\n        }\n    }catch(MalformedURLException e){\n        logger.error(\"Malformed URL\",e);\n    }catch(IOException e){\n        logger.error(\"IOException\",e);\n    }\n}",
               "ground_true": "@SuppressWarnings(\"unchecked\") public static void addToClassPath(Vector<URL> cpV,String dir){\n  try {\n    String cpComp[]=getFilesByExt(dir,\".jar\");\n    if (cpComp != null) {\n      int jarCount=cpComp.length;\n      for (int i=0; i < jarCount; i++) {\n        URL url=getURL(dir,cpComp[i]);\n        if (url != null)         cpV.addElement(url);\n      }\n    }\n  }\n catch (  Exception ex) {\n    logger.debug(\"failed to add urls to classpath\",ex);\n  }\n}\n"
          },
          {
               "id": "636766821a6d9265ec0174bf",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    1,
                    2
               ],
               "generate_code": "public static String capitalize(String name){\n    char[] chars = name.toCharArray();\n    chars[0] = Character.toUpperCase(chars[0]);\n    return new String(chars);\n}",
               "ground_true": "public static String capitalize(String name){\n  if (name == null || name.length() == 0) {\n    return name;\n  }\n  char chars[]=name.toCharArray();\n  chars[0]=Character.toUpperCase(chars[0]);\n  return new String(chars);\n}\n"
          },
          {
               "id": "6367667d1a6d9265ec01741d",
               "type": [
                    "Missing Type Checks on Variables",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    5,
                    2
               ],
               "generate_code": "public static Type resolveBound(TypeVariable<?> typeVariable){\n    if(typeVariable.getBounds().length==0)\n        return Unknown.class;\n    else\n        return typeVariable.getBounds()[0];\n}",
               "ground_true": "public static Type resolveBound(TypeVariable<?> typeVariable){\n  Type[] bounds=typeVariable.getBounds();\n  if (bounds.length == 0)   return Unknown.class;\n  Type bound=bounds[0];\n  if (bound instanceof TypeVariable)   bound=resolveBound((TypeVariable<?>)bound);\n  return bound == Object.class ? Unknown.class : bound;\n}\n"
          },
          {
               "id": "636766821a6d9265ec0174d2",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "public static AtmosphereRequest wrap(HttpServletRequest request){\n    return new AtmosphereRequest(request);\n}",
               "ground_true": "public static AtmosphereRequest wrap(HttpServletRequest request){\n  if (AtmosphereRequestImpl.class.isAssignableFrom(request.getClass())) {\n    return (AtmosphereRequestImpl)request;\n  }\n  Builder b=new Builder();\n  Enumeration<String> e=request.getAttributeNames();\n  String s;\n  while (e.hasMoreElements()) {\n    s=e.nextElement();\n    b.localAttributes.put(s,attributeWithoutException(request,s));\n  }\n  return b.request(request).build();\n}\n"
          },
          {
               "id": "636766821a6d9265ec0174b3",
               "type": [
                    "Missing Specific Value Checks",
                    "Missing Null Checks"
               ],
               "type_id": [
                    2,
                    1
               ],
               "generate_code": "protected Object filter(Object msg){\n    //TODO: Implement your filter logic here\n    return null;\n}",
               "ground_true": "protected Object filter(Object msg){\n  BroadcastAction a=bc.filter(msg);\n  if (a.action() == BroadcastAction.ACTION.ABORT || msg == null)   return null;\n else   return a.message();\n}\n"
          },
          {
               "id": "6367667c1a6d9265ec0173fb",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n  listeners.add(e);\n  return this;\n}",
               "ground_true": "@Override public AtmosphereResource addEventListener(AtmosphereResourceEventListener e){\n  if (listeners.contains(e))   return this;\n  listeners.add(e);\n  return this;\n}\n"
          },
          {
               "id": "636766821a6d9265ec0174c9",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "private static File[] classPath(){\n    return sun.misc.Launcher.loadClassPath().getFiles();\n}",
               "ground_true": "private static File[] classPath(){\n  final String[] fileNames=System.getProperty(\"java.class.path\").split(File.pathSeparator);\n  final File[] files=new File[fileNames.length];\n  for (int i=0; i < files.length; ++i) {\n    files[i]=new File(fileNames[i]);\n  }\n  return files;\n}\n"
          },
          {
               "id": "636766831a6d9265ec0174eb",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "private void addReverse(final File[] files){\n    stack = new LinkedList<>();\n    for(int i = files.length - 1; i >= 0; i--){\n        stack.push(files[i]);\n    }\n}",
               "ground_true": "private void addReverse(final File[] files){\n  if (files == null)   return;\n  for (int i=files.length - 1; i >= 0; --i) {\n    stack.add(files[i]);\n  }\n}\n"
          },
          {
               "id": "6367676d1a6d9265ec018229",
               "type": [
                    "Missing Boolean Value Checks",
                    "Missing Null Checks"
               ],
               "type_id": [
                    4,
                    1
               ],
               "generate_code": "public static String[] trimArrayElements(String[] array){\n    String[] trimmedArray = new String[array.length];\n    for(int i = 0; i < array.length; i++){\n        trimmedArray[i] = trimWhitespace(array[i]);\n    }\n    return trimmedArray;\n}",
               "ground_true": "public static String[] trimArrayElements(String[] array){\n  if (Objects.isEmpty(array)) {\n    return new String[0];\n  }\n  String[] result=new String[array.length];\n  for (int i=0; i < array.length; i++) {\n    String element=array[i];\n    result[i]=(element != null ? element.trim() : null);\n  }\n  return result;\n}\n"
          },
          {
               "id": "636767691a6d9265ec0181aa",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public static int nullSafeHashCode(long[] array){\n    int h = INITIAL_HASH;\n    for(long l : array){\n        h += l * MULTIPLIER;\n    }\n    return h;\n}",
               "ground_true": "public static int nullSafeHashCode(long[] array){\n  if (array == null) {\n    return 0;\n  }\n  int hash=INITIAL_HASH;\n  int arraySize=array.length;\n  for (int i=0; i < arraySize; i++) {\n    hash=MULTIPLIER * hash + hashCode(array[i]);\n  }\n  return hash;\n}\n"
          },
          {
               "id": "6367676b1a6d9265ec0181df",
               "type": [
                    "Missing Null Checks",
                    "Missing Boolean Value Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    1,
                    4,
                    3
               ],
               "generate_code": "public static boolean startsWithIgnoreCase(String str,String prefix){\n    return str.toLowerCase().startsWith(prefix.toLowerCase());\n}",
               "ground_true": "public static boolean startsWithIgnoreCase(String str,String prefix){\n  if (str == null || prefix == null) {\n    return false;\n  }\n  if (str.startsWith(prefix)) {\n    return true;\n  }\n  if (str.length() < prefix.length()) {\n    return false;\n  }\n  String lcStr=str.substring(0,prefix.length()).toLowerCase();\n  String lcPrefix=prefix.toLowerCase();\n  return lcStr.equals(lcPrefix);\n}\n"
          },
          {
               "id": "6367676b1a6d9265ec0181e2",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "public static Object findFirstMatch(Collection source,Collection candidates){\n    Iterator iterator = candidates.iterator();\n    while(iterator.hasNext()){\n        Object element = iterator.next();\n        if(source.contains(element)){\n            return element;\n        }\n    }\n    return null;\n}",
               "ground_true": "public static Object findFirstMatch(Collection source,Collection candidates){\n  if (isEmpty(source) || isEmpty(candidates)) {\n    return null;\n  }\n  for (  Object candidate : candidates) {\n    if (source.contains(candidate)) {\n      return candidate;\n    }\n  }\n  return null;\n}\n"
          },
          {
               "id": "6367676c1a6d9265ec01820b",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "public static String deleteAny(String inString,String charsToDelete){\n    StringBuilder result = new StringBuilder();\n    for(char c : inString.toCharArray()){\n        if(!charsToDelete.contains(String.valueOf(c))){\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
               "ground_true": "public static String deleteAny(String inString,String charsToDelete){\n  if (!hasLength(inString) || !hasLength(charsToDelete)) {\n    return inString;\n  }\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < inString.length(); i++) {\n    char c=inString.charAt(i);\n    if (charsToDelete.indexOf(c) == -1) {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}\n"
          },
          {
               "id": "6367676c1a6d9265ec018223",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public static boolean containsInstance(Collection collection,Object element){\n    return collection.contains(element);\n}",
               "ground_true": "public static boolean containsInstance(Collection collection,Object element){\n  if (collection != null) {\n    for (    Object candidate : collection) {\n      if (candidate == element) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"
          },
          {
               "id": "6367676c1a6d9265ec018204",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n    List<String> list = new ArrayList<String>();\n    list.addAll(Arrays.asList(array1));\n    list.addAll(Arrays.asList(array2));\n    return list.toArray(new String[0]);\n}",
               "ground_true": "public static String[] concatenateStringArrays(String[] array1,String[] array2){\n  if (Objects.isEmpty(array1)) {\n    return array2;\n  }\n  if (Objects.isEmpty(array2)) {\n    return array1;\n  }\n  String[] newArr=new String[array1.length + array2.length];\n  System.arraycopy(array1,0,newArr,0,array1.length);\n  System.arraycopy(array2,0,newArr,array1.length,array2.length);\n  return newArr;\n}\n"
          },
          {
               "id": "6367676a1a6d9265ec0181d4",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "public static String[] addStringToArray(String[] array,String str){\n    String[] newArray = new String[array.length + 1];\n    System.arraycopy(array, 0, newArray, 0, array.length);\n    newArray[newArray.length - 1] = str;\n    return newArray;\n}",
               "ground_true": "public static String[] addStringToArray(String[] array,String str){\n  if (Objects.isEmpty(array)) {\n    return new String[]{str};\n  }\n  String[] newArr=new String[array.length + 1];\n  System.arraycopy(array,0,newArr,0,array.length);\n  newArr[array.length]=str;\n  return newArr;\n}\n"
          },
          {
               "id": "6367676b1a6d9265ec0181dd",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    1,
                    2
               ],
               "generate_code": "public static int countOccurrencesOf(String str,String sub){\n    int count = 0;\n    int index = 0;\n    while(index != -1){\n        index = str.indexOf(sub,index);\n        if(index != -1){\n            count++;\n            index += sub.length();\n        }\n    }\n    return count;\n}",
               "ground_true": "public static int countOccurrencesOf(String str,String sub){\n  if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {\n    return 0;\n  }\n  int count=0;\n  int pos=0;\n  int idx;\n  while ((idx=str.indexOf(sub,pos)) != -1) {\n    ++count;\n    pos=idx + sub.length();\n  }\n  return count;\n}\n"
          },
          {
               "id": "6367676c1a6d9265ec018220",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    1,
                    2,
                    3
               ],
               "generate_code": "public static String stripFilenameExtension(String path){\n    return FilenameUtils.removeExtension(path);\n}",
               "ground_true": "public static String stripFilenameExtension(String path){\n  if (path == null) {\n    return null;\n  }\n  int extIndex=path.lastIndexOf(EXTENSION_SEPARATOR);\n  if (extIndex == -1) {\n    return path;\n  }\n  int folderIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n  if (folderIndex > extIndex) {\n    return path;\n  }\n  return path.substring(0,extIndex);\n}\n"
          },
          {
               "id": "636767691a6d9265ec0181a6",
               "type": [
                    "Missing Boolean Value Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    4,
                    3
               ],
               "generate_code": "public static String[] split(String toSplit,String delimiter){\n    return toSplit.split(delimiter, 2);\n}",
               "ground_true": "public static String[] split(String toSplit,String delimiter){\n  if (!hasLength(toSplit) || !hasLength(delimiter)) {\n    return null;\n  }\n  int offset=toSplit.indexOf(delimiter);\n  if (offset < 0) {\n    return null;\n  }\n  String beforeDelimiter=toSplit.substring(0,offset);\n  String afterDelimiter=toSplit.substring(offset + delimiter.length());\n  return new String[]{beforeDelimiter,afterDelimiter};\n}\n"
          },
          {
               "id": "636767691a6d9265ec0181ac",
               "type": [
                    "Missing Specific Value Checks",
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    2,
                    4
               ],
               "generate_code": "public static String applyRelativePath(String path,String relativePath){\n    int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);\n    String newPath = path.substring(0,folderIndex) + FOLDER_SEPARATOR + relativePath;\n    return newPath;\n}",
               "ground_true": "public static String applyRelativePath(String path,String relativePath){\n  int separatorIndex=path.lastIndexOf(FOLDER_SEPARATOR);\n  if (separatorIndex != -1) {\n    String newPath=path.substring(0,separatorIndex);\n    if (!relativePath.startsWith(FOLDER_SEPARATOR)) {\n      newPath+=FOLDER_SEPARATOR;\n    }\n    return newPath + relativePath;\n  }\n else {\n    return relativePath;\n  }\n}\n"
          },
          {
               "id": "6367676b1a6d9265ec0181e9",
               "type": [
                    "Inconsistent Expression"
               ],
               "type_id": [
                    9
               ],
               "generate_code": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n    if(str.length() <= index || substring.length() > str.length() - index)\n        return false;\n    return str.subSequence(index, index + substring.length()).equals(substring);\n}",
               "ground_true": "public static boolean substringMatch(CharSequence str,int index,CharSequence substring){\n  for (int j=0; j < substring.length(); j++) {\n    int i=index + j;\n    if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\n      return false;\n    }\n  }\n  return true;\n}\n"
          },
          {
               "id": "6367677e1a6d9265ec01830f",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public String format(LoggingEvent event){\n    synchronized (this) {\n        if (pattern == null) {\n            pattern = DEFAULT_CONVERSION_PATTERN;\n        }\n        PatternParser pp = createPatternParser(pattern);\n        sbuf = new StringBuffer();\n        head = pp.next();\n        while (head != null) {\n            head.format(sbuf, event);\n            head = pp.next();\n        }\n        return sbuf.toString();\n    }\n}",
               "ground_true": "public String format(LoggingEvent event){\n  if (sbuf.capacity() > MAX_CAPACITY) {\n    sbuf=new StringBuffer(BUF_SIZE);\n  }\n else {\n    sbuf.setLength(0);\n  }\n  PatternConverter c=head;\n  while (c != null) {\n    c.format(sbuf,event);\n    c=c.next;\n  }\n  return sbuf.toString();\n}\n"
          },
          {
               "id": "636767831a6d9265ec0183c9",
               "type": [
                    "Missing Null Checks",
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    1,
                    4
               ],
               "generate_code": "public static String peek(){\n    return stack.peek();\n}",
               "ground_true": "public static String peek(){\n  Stack stack=getCurrentStack();\n  if (stack != null && !stack.isEmpty())   return ((DiagnosticContext)stack.peek()).message;\n else   return \"\";\n}\n"
          },
          {
               "id": "6367677e1a6d9265ec01832e",
               "type": [
                    "Missing Type Checks on Variables"
               ],
               "type_id": [
                    5
               ],
               "generate_code": "public Logger exists(String name){\n    return ht.get(name);\n}",
               "ground_true": "public Logger exists(String name){\n  Object o=ht.get(new CategoryKey(name));\n  if (o instanceof Logger) {\n    return (Logger)o;\n  }\n else {\n    return null;\n  }\n}\n"
          },
          {
               "id": "636767791a6d9265ec018257",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "public void addMessage(final LogRecord lr){\n    SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n            _table.addMessage(lr);\n        }\n    });\n}",
               "ground_true": "public void addMessage(final LogRecord lr){\n  if (_isDisposed == true) {\n    return;\n  }\n  SwingUtilities.invokeLater(new Runnable(){\n    public void run(){\n      _categoryExplorerTree.getExplorerModel().addLogRecord(lr);\n      _table.getFilteredLogTableModel().addLogRecord(lr);\n      updateStatusLabel();\n    }\n  }\n);\n}\n"
          },
          {
               "id": "636767841a6d9265ec0183ff",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public static void selectRow(int row,JTable table,JScrollPane pane){\n    table.setSelectionRow(row);\n    pane.setViewportView(table);\n}",
               "ground_true": "public static void selectRow(int row,JTable table,JScrollPane pane){\n  if (table == null || pane == null) {\n    return;\n  }\n  if (contains(row,table.getModel()) == false) {\n    return;\n  }\n  moveAdjustable(row * table.getRowHeight(),pane.getVerticalScrollBar());\n  selectRow(row,table.getSelectionModel());\n  repaintLater(table);\n}\n"
          },
          {
               "id": "636767781a6d9265ec01823e",
               "type": [
                    "Missing Null Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    1,
                    3
               ],
               "generate_code": "protected void append(LoggingEvent event){\n    String message = event.getRenderedMessage();\n    if(layout.ignoresThrowable()){\n        message = message + \" \" + event.getThrowableInformation();\n    }\n    send(message);\n}",
               "ground_true": "protected void append(LoggingEvent event){\n  if (sh != null) {\n    sh.send(layout.format(event));\n    if (layout.ignoresThrowable()) {\n      String[] s=event.getThrowableStrRep();\n      if (s != null) {\n        StringBuffer buf=new StringBuffer();\n        for (int i=0; i < s.length; i++) {\n          buf.append(s[i]);\n          buf.append(\"\\r\\n\");\n        }\n        sh.send(buf.toString());\n      }\n    }\n  }\n}\n"
          },
          {
               "id": "6367677f1a6d9265ec01834b",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public void put(LoggingEvent o){\n    buf[next] = o;\n    next = (next + 1) % maxSize;\n}",
               "ground_true": "public void put(LoggingEvent o){\n  if (numElements != maxSize) {\n    buf[next]=o;\n    if (++next == maxSize) {\n      next=0;\n    }\n    numElements++;\n  }\n}\n"
          },
          {
               "id": "636767781a6d9265ec018238",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public boolean isAttached(Appender appender){\n    if(appenderList.contains(appender)){\n        return true;\n    }else{\n        return false;\n    }\n}",
               "ground_true": "public boolean isAttached(Appender appender){\n  if (appenderList == null || appender == null)   return false;\n  int size=appenderList.size();\n  Appender a;\n  for (int i=0; i < size; i++) {\n    a=(Appender)appenderList.elementAt(i);\n    if (a == appender)     return true;\n  }\n  return false;\n}\n"
          },
          {
               "id": "636767841a6d9265ec0183e8",
               "type": [
                    "Inconsistent Expression",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    9,
                    2
               ],
               "generate_code": "public void add(LoggingEvent event){\n    if(numElems == maxSize){\n        resize(maxSize * 2);\n    }\n    ea[last] = event;\n    last = (last + 1) % maxSize;\n    numElems++;\n}",
               "ground_true": "public void add(LoggingEvent event){\n  ea[last]=event;\n  if (++last == maxSize)   last=0;\n  if (numElems < maxSize)   numElems++;\n else   if (++first == maxSize)   first=0;\n}\n"
          },
          {
               "id": "636767861a6d9265ec01844c",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public void removeAppender(String name){\n    if(appenderList != null){\n        for(Enumeration e = appenderList.elements(); e.hasMoreElements();){\n            Appender appender = (Appender) e.nextElement();\n            if(appender.getName().equals(name)){\n                appenderList.removeElement(appender);\n                break;\n            }\n        }\n    }\n}",
               "ground_true": "public void removeAppender(String name){\n  if (name == null || appenderList == null)   return;\n  int size=appenderList.size();\n  for (int i=0; i < size; i++) {\n    if (name.equals(((Appender)appenderList.elementAt(i)).getName())) {\n      appenderList.removeElementAt(i);\n      break;\n    }\n  }\n}\n"
          },
          {
               "id": "636767821a6d9265ec0183ab",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public boolean hasThrown(){\n    return _thrown != null;\n}",
               "ground_true": "public boolean hasThrown(){\n  Throwable thrown=getThrown();\n  if (thrown == null) {\n    return false;\n  }\n  String thrownString=thrown.toString();\n  return thrownString != null && thrownString.trim().length() != 0;\n}\n"
          },
          {
               "id": "6367677e1a6d9265ec018314",
               "type": [
                    "Errorous Expression",
                    "Missing Null Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    8,
                    1,
                    2
               ],
               "generate_code": "protected int removeUnusedNodes(){\n    int removedNodes = 0;\n    ArrayList<CategoryNode> nodesToRemove = new ArrayList<CategoryNode>();\n    for(Enumeration<CategoryNode> e = _categoryModel.getRootNodes().elements(); e.hasMoreElements();){\n        CategoryNode node = e.nextElement();\n        if(!node.isActive()){\n            nodesToRemove.add(node);\n            removedNodes++;\n        }\n    }\n    for(CategoryNode node : nodesToRemove){\n        _categoryModel.removeNode(node);\n    }\n    return removedNodes;\n}",
               "ground_true": "protected int removeUnusedNodes(){\n  int count=0;\n  CategoryNode root=_categoryModel.getRootCategoryNode();\n  Enumeration enumeration=root.depthFirstEnumeration();\n  while (enumeration.hasMoreElements()) {\n    CategoryNode node=(CategoryNode)enumeration.nextElement();\n    if (node.isLeaf() && node.getNumberOfContainedRecords() == 0 && node.getParent() != null) {\n      _categoryModel.removeNodeFromParent(node);\n      count++;\n    }\n  }\n  return count;\n}\n"
          },
          {
               "id": "636767841a6d9265ec0183f2",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public int compare(Object aObj1,Object aObj2){\n    EventDetails aEvent1 = (EventDetails) aObj1;\n    EventDetails aEvent2 = (EventDetails) aObj2;\n    return aEvent1.getTimeStamp().compareTo(aEvent2.getTimeStamp());\n}",
               "ground_true": "public int compare(Object aObj1,Object aObj2){\n  if ((aObj1 == null) && (aObj2 == null)) {\n    return 0;\n  }\n else   if (aObj1 == null) {\n    return -1;\n  }\n else   if (aObj2 == null) {\n    return 1;\n  }\n  final EventDetails le1=(EventDetails)aObj1;\n  final EventDetails le2=(EventDetails)aObj2;\n  if (le1.getTimeStamp() < le2.getTimeStamp()) {\n    return 1;\n  }\n  return -1;\n}\n"
          },
          {
               "id": "636767781a6d9265ec018250",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public int decide(LoggingEvent event){\n    String message = event.getRenderedMessage();\n    if(stringToMatch != null && message.contains(stringToMatch)){\n        return acceptOnMatch ? Filter.ACCEPT : Filter.NEUTRAL;\n    }\n    return Filter.DENY;\n}",
               "ground_true": "public int decide(LoggingEvent event){\n  String msg=event.getRenderedMessage();\n  if (msg == null || stringToMatch == null)   return Filter.NEUTRAL;\n  if (msg.indexOf(stringToMatch) == -1) {\n    return Filter.NEUTRAL;\n  }\n else {\n    if (acceptOnMatch) {\n      return Filter.ACCEPT;\n    }\n else {\n      return Filter.DENY;\n    }\n  }\n}\n"
          },
          {
               "id": "636767df1a6d9265ec01873c",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "public String id(String entityId){\n    return Const.ID_CONNECTOR + point + entityId;\n}",
               "ground_true": "public String id(String entityId){\n  if (entityId == null) {\n    return String.valueOf(point);\n  }\n else {\n    return point + Const.ID_CONNECTOR + entityId;\n  }\n}\n"
          },
          {
               "id": "636767df1a6d9265ec018744",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "protected List<TimeRange> buildTimeRanges(long start,long end){\n    List<TimeRange> timeRanges = new ArrayList<>();\n    long currentStart = start;\n    while(currentStart <= end){\n        long currentEnd = Math.min(currentStart + FETCH_DATA_DURATION, end);\n        timeRanges.add(new TimeRange(currentStart, currentEnd));\n        currentStart = currentEnd + 1;\n    }\n    return timeRanges;\n}",
               "ground_true": "protected List<TimeRange> buildTimeRanges(long start,long end){\n  if (start >= end) {\n    return null;\n  }\n  end+=1;\n  final List<TimeRange> timeRanges=new ArrayList<>();\n  do {\n    long batchEnd=Math.min(start + FETCH_DATA_DURATION,end);\n    timeRanges.add(new TimeRange(start,batchEnd));\n    start=batchEnd;\n  }\n while (start < end);\n  return timeRanges;\n}\n"
          },
          {
               "id": "636767e01a6d9265ec018755",
               "type": [
                    "Missing Null Checks"
               ],
               "type_id": [
                    1
               ],
               "generate_code": "private Map<String,Object> buildContent(JsonObject jsonObject){\n    Map<String,Object> content = new HashMap<>();\n    content.put(\"msg_type\", \"text\");\n    content.put(\"text\", jsonObject.get(\"content\").getAsString());\n    return content;\n}",
               "ground_true": "private Map<String,Object> buildContent(JsonObject jsonObject){\n  Map<String,Object> content=new HashMap<>();\n  content.put(\"msg_type\",jsonObject.get(\"msg_type\").getAsString());\n  if (jsonObject.get(\"ats\") != null) {\n    String ats=jsonObject.get(\"ats\").getAsString();\n    String text=jsonObject.get(\"content\").getAsJsonObject().get(\"text\").getAsString();\n    List<String> collect=Arrays.stream(ats.split(\",\")).map(String::trim).collect(Collectors.toList());\n    for (    String userId : collect) {\n      text+=\"<at user_id=\\\"\" + userId + \"\\\"></at>\";\n    }\n    jsonObject.get(\"content\").getAsJsonObject().addProperty(\"text\",text);\n  }\n  content.put(\"content\",jsonObject.get(\"content\").getAsJsonObject());\n  return content;\n}\n"
          },
          {
               "id": "636767de1a6d9265ec018706",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "public Mappings diffStructure(String tableName,Mappings mappings){\n    Map<String,Fields> structures = getMapping(tableName);\n    Mappings.Source source = mappings.getSource();\n    Map<String,Object> properties = source.getProperties();\n    Map<String,Fields> newStructures = structures.entrySet().stream()\n        .filter(entry -> !containsAllFields(entry.getValue(),properties.keySet()))\n        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    source.setProperties(newStructures);\n    return new Mappings(source);\n}",
               "ground_true": "public Mappings diffStructure(String tableName,Mappings mappings){\n  if (!structures.containsKey(tableName)) {\n    return new Mappings();\n  }\n  Map<String,Object> properties=mappings.getProperties();\n  Map<String,Object> diffProperties=structures.get(tableName).diffFields(new Fields(mappings));\n  return Mappings.builder().type(ElasticSearchClient.TYPE).properties(diffProperties).build();\n}\n"
          },
          {
               "id": "636767dc1a6d9265ec0186be",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "static long compressTimeBucket(long timeBucket,int dayStep){\n    long compressedTimeBucket = timeBucket - (timeBucket % (1000 * 60 * 60 * 24 * dayStep));\n    return compressedTimeBucket;\n}",
               "ground_true": "static long compressTimeBucket(long timeBucket,int dayStep){\n  if (dayStep > 1) {\n    DateTime time=TIME_BUCKET_FORMATTER.parseDateTime(\"\" + timeBucket);\n    int days=Days.daysBetween(DAY_ONE,time).getDays();\n    int groupBucketOffset=days % dayStep;\n    return Long.parseLong(time.minusDays(groupBucketOffset).toString(TIME_BUCKET_FORMATTER));\n  }\n else {\n    return timeBucket;\n  }\n}\n"
          },
          {
               "id": "636767dc1a6d9265ec0186c6",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "private boolean containsAllFields(Fields fields){\n    return properties.entrySet().stream()\n            .allMatch(entry -> fields.contains(entry.getKey()));\n}",
               "ground_true": "private boolean containsAllFields(Fields fields){\n  if (this.properties.size() < fields.properties.size()) {\n    return false;\n  }\n  boolean isContains=fields.properties.entrySet().stream().allMatch(item -> Objects.equals(properties.get(item.getKey()),item.getValue()));\n  if (!isContains) {\n    return false;\n  }\n  return fields.source.getExcludes().containsAll(this.source.getExcludes());\n}\n"
          },
          {
               "id": "636767dc1a6d9265ec0186cb",
               "type": [
                    "Missing Boolean Value Checks"
               ],
               "type_id": [
                    4
               ],
               "generate_code": "public void init(){\n    File dir = new File(analyzeResultDist);\n    if (!dir.exists()) {\n        dir.mkdirs();\n    }\n}",
               "ground_true": "public void init(){\n  File dist=new File(analyzeResultDist);\n  if (!dist.exists()) {\n    dist.mkdirs();\n    return;\n  }\n  if (dist.isFile()) {\n    throw new IllegalArgumentException(analyzeResultDist + \" must be a directory\");\n  }\n}\n"
          },
          {
               "id": "636766a91a6d9265ec0175c2",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "private int pop(){\n    int result = outputStack[outputStackTop--];\n    return result;\n}",
               "ground_true": "private int pop(){\n  if (outputStackTop > 0) {\n    return outputStack[--outputStackTop];\n  }\n else {\n    return STACK_KIND | -(--outputStackStart);\n  }\n}\n"
          },
          {
               "id": "636766aa1a6d9265ec0175ce",
               "type": [
                    "Missing Null Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    1,
                    3
               ],
               "generate_code": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n    currentFrame = new int[3];\n    currentFrame[0] = offset;\n    currentFrame[1] = numLocal;\n    currentFrame[2] = numStack;\n    return 3;\n}",
               "ground_true": "int visitFrameStart(final int offset,final int numLocal,final int numStack){\n  int frameLength=3 + numLocal + numStack;\n  if (currentFrame == null || currentFrame.length < frameLength) {\n    currentFrame=new int[frameLength];\n  }\n  currentFrame[0]=offset;\n  currentFrame[1]=numLocal;\n  currentFrame[2]=numStack;\n  return 3;\n}\n"
          },
          {
               "id": "636766a91a6d9265ec0175c1",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "private void enlarge(final int size){\n    byte[] newData = new byte[data.length + size];\n    System.arraycopy(data, 0, newData, 0, data.length);\n    data = newData;\n}",
               "ground_true": "private void enlarge(final int size){\n  int doubleCapacity=2 * data.length;\n  int minimalCapacity=length + size;\n  byte[] newData=new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\n  System.arraycopy(data,0,newData,0,length);\n  data=newData;\n}\n"
          },
          {
               "id": "636766a81a6d9265ec017596",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public ByteVector putInt(final int intValue){\n    byte[] bytes = new byte[4];\n    bytes[3] = (byte)((intValue >> 24) & 0xFF);\n    bytes[2] = (byte)((intValue >> 16) & 0xFF);\n    bytes[1] = (byte)((intValue >> 8) & 0xFF);\n    bytes[0] = (byte)(intValue & 0xFF);\n    putByteArray(bytes,0,4);\n    return this;\n}",
               "ground_true": "public ByteVector putInt(final int intValue){\n  int currentLength=length;\n  if (currentLength + 4 > data.length) {\n    enlarge(4);\n  }\n  byte[] currentData=data;\n  currentData[currentLength++]=(byte)(intValue >>> 24);\n  currentData[currentLength++]=(byte)(intValue >>> 16);\n  currentData[currentLength++]=(byte)(intValue >>> 8);\n  currentData[currentLength++]=(byte)intValue;\n  length=currentLength;\n  return this;\n}\n"
          },
          {
               "id": "636766a81a6d9265ec017595",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "final ByteVector put11(final int byteValue1,final int byteValue2){\n    putByte(byteValue1);\n    putByte(byteValue2);\n    return this;\n}",
               "ground_true": "final ByteVector put11(final int byteValue1,final int byteValue2){\n  int currentLength=length;\n  if (currentLength + 2 > data.length) {\n    enlarge(2);\n  }\n  byte[] currentData=data;\n  currentData[currentLength++]=(byte)byteValue1;\n  currentData[currentLength++]=(byte)byteValue2;\n  length=currentLength;\n  return this;\n}\n"
          },
          {
               "id": "636766a81a6d9265ec01757b",
               "type": [
                    "Missing Null Checks",
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    1,
                    2
               ],
               "generate_code": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n    JSONWriter writer = new JSONWriter(features);\n    writer.write(this);\n    return writer.toString();\n}",
               "ground_true": "@SuppressWarnings(\"unchecked\") public String toString(JSONWriter.Feature... features){\n  try (JSONWriter writer=JSONWriter.of(features)){\n    if ((writer.context.features & NONE_DIRECT_FEATURES) == 0) {\n      writer.write(this);\n    }\n else {\n      writer.setRootObject(this);\n      if (arrayWriter == null) {\n        arrayWriter=writer.getObjectWriter(JSONArray.class,JSONArray.class);\n      }\n      arrayWriter.write(writer,this,null,null,0);\n    }\n    return writer.toString();\n  }\n }\n"
          },
          {
               "id": "636767a61a6d9265ec0185b7",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "private static int digitValue(final char c){\n    return c - '0';\n}",
               "ground_true": "private static int digitValue(final char c){\n  if ('0' <= c && c <= '9') {\n    return c - '0';\n  }\n else   if ('a' <= c && c <= 'z') {\n    return c - 'a' + 10;\n  }\n else {\n    return c - 'A' + 10;\n  }\n}\n"
          },
          {
               "id": "636767a41a6d9265ec018582",
               "type": [
                    "Missing Specific Value Checks"
               ],
               "type_id": [
                    2
               ],
               "generate_code": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n    ProtobufOutput protobufOutput = new ProtobufOutput(out,schema,buffer);\n    protobufOutput.writeMessage(message);\n    return protobufOutput.getWrittenBytes();\n}",
               "ground_true": "public static <T>int writeDelimitedTo(OutputStream out,T message,Schema<T> schema,LinkedBuffer buffer) throws IOException {\n  if (buffer.start != buffer.offset)   throw new IllegalArgumentException(\"Buffer previously used and had not been reset.\");\n  final ProtobufOutput output=new ProtobufOutput(buffer);\n  schema.writeTo(output,message);\n  final int size=output.getSize();\n  ProtobufOutput.writeRawVarInt32Bytes(out,size);\n  final int msgSize=LinkedBuffer.writeTo(out,buffer);\n  assert size == msgSize;\n  return size;\n}\n"
          },
          {
               "id": "636767a31a6d9265ec018552",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "@Override public String readString() throws IOException {\n  int length = readInt32();\n  byte[] bytes = new byte[length];\n  readBytes(ByteBuffer.wrap(bytes));\n  return new String(bytes, \"UTF-8\");\n}",
               "ground_true": "@Override public String readString() throws IOException {\n  final int size=readRawVarint32();\n  if (size <= (bufferSize - bufferPos) && size > 0) {\n    final String result=STRING.deser(buffer,bufferPos,size);\n    bufferPos+=size;\n    return result;\n  }\n else {\n    return STRING.deser(readRawBytes(size));\n  }\n}\n"
          },
          {
               "id": "636767a21a6d9265ec018517",
               "type": [
                    "Missing Range Checks"
               ],
               "type_id": [
                    3
               ],
               "generate_code": "public final byte[] toByteArray(){\n    byte[] array = new byte[getSize()];\n    int offset = 0;\n    for(LinkedBuffer lb : this){\n        byte[] b = lb.toByteArray(offset);\n        System.arraycopy(b, 0, array, offset, b.length);\n        offset += b.length;\n    }\n    return array;\n}",
               "ground_true": "public final byte[] toByteArray(){\n  LinkedBuffer node=head;\n  int offset=0, len;\n  final byte[] buf=new byte[size];\n  do {\n    if ((len=node.offset - node.start) > 0) {\n      System.arraycopy(node.buffer,node.start,buf,offset,len);\n      offset+=len;\n    }\n  }\n while ((node=node.next) != null);\n  return buf;\n}\n"
          },
          {
               "id": "636767a31a6d9265ec01854f",
               "type": [
                    "Missing Specific Value Checks",
                    "Missing Range Checks"
               ],
               "type_id": [
                    2,
                    3
               ],
               "generate_code": "private void checkIfPackedField() throws IOException {\n    if (isCurrentFieldPacked()) {\n        readFieldNumber(schema);\n    }\n}",
               "ground_true": "private void checkIfPackedField() throws IOException {\n  if (packedLimit == 0 && WireFormat.getTagWireType(lastTag) == WIRETYPE_LENGTH_DELIMITED) {\n    final int length=readRawVarint32();\n    if (length < 0)     throw ProtobufException.negativeSize();\n    this.packedLimit=getTotalBytesRead() + length;\n  }\n}\n"
          },
          {
               "id": "636767a81a6d9265ec0185fc",
               "type": [
                    "Missing Boolean Value Checks",
                    "Inconsistent Expression"
               ],
               "type_id": [
                    4,
                    9
               ],
               "generate_code": "public int readTag() throws IOException {\n    int tag = this.readRawVarint32();\n    if (tag == 0) {\n        throw new IOException(\"Unexpected EOF\");\n    }\n    return tag;\n}",
               "ground_true": "public int readTag() throws IOException {\n  if (!buffer.hasRemaining()) {\n    lastTag=0;\n    return 0;\n  }\n  final int tag=readRawVarint32();\n  if (tag >>> TAG_TYPE_BITS == 0) {\n    throw ProtobufException.invalidTag();\n  }\n  lastTag=tag;\n  return tag;\n}\n"
          }
     ]
}